import uuid
import os
import requests
import logging
from urllib.parse import parse_qs
from decimal import Decimal
from django.db import models, transaction
from django.core.exceptions import ValidationError
from django.conf import settings
from dotenv import load_dotenv

from accounts.choices import UserKind  # Importing role choices
from review.models import Review
from store.models import Store  # âœ… Corrected Import

# Load environment variables from the .env file
load_dotenv()

logger = logging.getLogger(__name__)


class Balance(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,  # Lazy reference to the custom user model
        on_delete=models.CASCADE,
        related_name="balance",
        help_text="The user whose balance is being tracked"
    )
    current_balance = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        help_text="The current balance of the user"
    )
    total_received = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        help_text="The total amount received by the user"
    )
    last_updated = models.DateTimeField(
        auto_now=True,
        help_text="The last time the balance was updated"
    )

    def update_balance(self, amount):
        """
        Update the balance with the given amount.
        """
        self.current_balance += amount
        self.total_received += amount
        self.save()


class GMOCreditPayment(models.Model):
    STATUS_CHOICES = [
        ("PENDING", "Pending"),
        ("CAPTURE", "Captured"),
        ("FAILED", "Failed"),
        ("CANCELED", "Canceled"),
    ]

    order_id = models.CharField(
        max_length=50, unique=True, db_index=True,
        help_text="Unique identifier for the payment transaction"
    )
    customer = models.ForeignKey(
        settings.AUTH_USER_MODEL,  # Lazy reference to the custom user model
        on_delete=models.SET_NULL, null=True, blank=True,
        related_name="gmo_payments",
        help_text="Authenticated customer (nullable for anonymous users)"
    )
    nickname = models.CharField(
        max_length=100, blank=True, null=True,
        help_text="Nickname for the payer (optional for unauthenticated users)"
    )

    # UUIDs for entity relationships
    staff_uid = models.UUIDField(
        default=uuid.uuid4, editable=False, db_index=True,
        help_text="Unique identifier for staff receiving the tip"
    )
    store_uid = models.UUIDField(
        default=uuid.uuid4, blank=True, null=True, db_index=True,
        help_text="Unique identifier for store (optional)"
    )

    amount = models.DecimalField(
        max_digits=10, decimal_places=2,
        help_text="Payment amount"
    )
    currency = models.CharField(
        max_length=10, default="JPY",
        help_text="Currency of the payment"
    )

    status = models.CharField(
        max_length=20, choices=STATUS_CHOICES, default="PENDING",
        help_text="Status of the payment"
    )
    transaction_id = models.CharField(
        max_length=100, blank=True, null=True,
        help_text="Transaction ID generated by GMO"
    )
    approval_code = models.CharField(
        max_length=50, blank=True, null=True,
        help_text="Approval code from GMO"
    )
    process_date = models.DateTimeField(blank=True, null=True)

    access_id = models.CharField(max_length=100, blank=True, null=True)
    access_pass = models.CharField(max_length=100, blank=True, null=True)
    token = models.CharField(max_length=512, blank=True, null=True)

    card_last4 = models.CharField(
        max_length=4, blank=True, null=True,
        help_text="Last 4 digits of the credit card"
    )
    expire_date = models.CharField(
        max_length=5, blank=True, null=True,
        help_text="Credit card expiry date (MMYY)"
    )

    forward = models.CharField(max_length=100, blank=True, null=True)
    pay_method = models.CharField(max_length=50, blank=True, null=True)

    is_processed = models.BooleanField(
        default=False, help_text="Indicates if the payment has been processed"
    )
    message = models.TextField(blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    is_distributed = models.BooleanField(
        default=False,
        help_text="Indicates if the payment amount has been distributed"
    )

    def __str__(self):
        return f"Order {self.order_id} - {self.status}"

    class Meta:
        ordering = ["-created_at"]

    # ---------------------
    # Dynamic Relationship Properties
    # ---------------------
    @property
    def restaurant(self):
        """
        Dynamically fetch the restaurant based on the store.
        """
        try:
            store = Store.objects.get(uid=self.store_uid)
            return store.restaurant if store else None
        except Store.DoesNotExist:
            return None

    @property
    def sales_agent(self):
        """
        Dynamically fetch the sales agent based on the restaurant.
        """
        restaurant = self.restaurant
        return restaurant.sales_agent if restaurant else None

    # ---------------------
    # Payment Status Check Helper
    # ---------------------
    def check_payment_status(self):
        """
        Checks the payment status with the GMO API.
        If the status returned is 'CAPTURE', update the model accordingly.
        """
        shop_id = os.environ.get("GMO_SHOP_ID")
        shop_pass = os.environ.get("GMO_SHOP_PASS")
        base_url = os.environ.get("GMO_API_URL")
        url = f"{base_url}/payment/SearchTrade.idPass"
        payload = {
            "ShopID": shop_id,
            "ShopPass": shop_pass,
            "OrderID": self.order_id
        }
        try:
            response = requests.post(url, data=payload)
        except requests.RequestException as e:
            logger.error("Request to GMO API failed: %s", str(e))
            return None

        if response.status_code == 200:
            parsed_response = parse_qs(response.text)
            status_value = parsed_response.get("Status", [None])[0]
            if status_value == "CAPTURE":
                self.status = "CAPTURE"
                self.save(update_fields=["status"])
                if self.message:
                    review = Review.objects.create(
                        payment=self,
                        payment_type="GMOCreditPayment",
                        transaction_id=self.order_id,
                        consumer=self.customer if self.customer else None,
                        consumer_name=self.customer.name if self.customer.name else "Anonymous",
                        message=self.message,
                        store_uid=self.store_uid,
                    )
            return parsed_response
        else:
            logger.error("GMO API responded with status code %s", response.status_code)
            return None

    def distribute_payment(self):
        """
        Distribute the payment amount to Staff, Glow Admin, FC Admin, and Sales Agent.
        This method calculates commission, net amount, and updates the balances accordingly.
        Distribution is allowed only if payment status is 'CAPTURE'.
        """
        if self.status != "CAPTURE":
            logger.error("Cannot distribute payment for order_id %s as status is not CAPTURE.", self.order_id)
            return

        if self.is_distributed:
            logger.info("Payment with order_id %s has already been distributed.", self.order_id)
            return

        with transaction.atomic():
            paypal_commission = (self.amount * Decimal("0.036")) + Decimal("40")
            net_amount = self.amount - paypal_commission

            staff_share = net_amount * Decimal("0.75")
            management_share = net_amount * Decimal("0.25")
            glow_share = management_share * Decimal("0.30")
            fc_share = management_share * Decimal("0.30")
            sales_agent_share = management_share * Decimal("0.40")

            from django.contrib.auth import get_user_model
            User = get_user_model()

            try:
                staff = User.objects.get(uid=self.staff_uid)
                if hasattr(staff, "balance"):
                    staff.balance.update_balance(staff_share)
                    logger.info("Staff balance updated by %s for order_id %s", staff_share, self.order_id)
            except User.DoesNotExist:
                logger.error("Staff user with uid %s not found during distribution.", self.staff_uid)
                raise Exception("Staff user not found for distribution.")

            glow_admin = User.objects.filter(kind=UserKind.GLOW_ADMIN).first()
            if glow_admin and hasattr(glow_admin, "balance"):
                glow_admin.balance.update_balance(glow_share)
                logger.info("Glow Admin balance updated by %s for order_id %s", glow_share, self.order_id)

            fc_admin = User.objects.filter(kind=UserKind.FC_ADMIN).first()
            if fc_admin and hasattr(fc_admin, "balance"):
                fc_admin.balance.update_balance(fc_share)
                logger.info("FC Admin balance updated by %s for order_id %s", fc_share, self.order_id)

            sales_agent = self.sales_agent
            if sales_agent and hasattr(sales_agent, "balance"):
                sales_agent.balance.update_balance(sales_agent_share)
                logger.info("Sales Agent balance updated by %s for order_id %s", sales_agent_share, self.order_id)

            self.is_distributed = True
            self.save(update_fields=["is_distributed"])
            logger.info("Payment with order_id %s marked as distributed.", self.order_id)


## PayPal For Disbursements ##
from django.db import models
from django.conf import settings

class PayPalDetail(models.Model):
    """
    Stores PayPal account details for users.

    For Sales Agents, Restaurant Owners, and Staff, each user should have their individual
    PayPal account linked. For FC Admin and Glow Admin users, a single shared PayPal account
    is used, so the 'user' field can remain null.
    """
    ACCOUNT_TYPE_CHOICES = [
        ('individual', 'Individual'),
        ('fc_admin', 'FC Admin'),
        ('glow_admin', 'Glow Admin'),
    ]
    
    # Link for individual accounts; leave blank for shared accounts.
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        help_text="Linked user for individual PayPal accounts. Use null for shared accounts."
    )
    account_type = models.CharField(
        max_length=20,
        choices=ACCOUNT_TYPE_CHOICES,
        default='individual',
        help_text="Indicates if the account is individual or shared (for FC Admin or Glow Admin)."
    )
    paypal_email = models.EmailField(
        unique=True,
        help_text="The PayPal email address associated with the account."
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        if self.user:
            return f"{self.user} - {self.paypal_email}"
        return f"{self.account_type} - {self.paypal_email}"


class PayPalDisbursement(models.Model):
    """
    Logs disbursement transactions from a user's balance to their PayPal account.

    This model records the details for each payout attempt (scheduled on the last day
    of the month when the user's balance is at least 3000 JPY). It is used for auditing and
    troubleshooting disbursement operations.
    """
    STATUS_CHOICES = [
        ("PENDING", "Pending"),
        ("COMPLETED", "Completed"),
        ("FAILED", "Failed"),
    ]
    
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="paypal_disbursements",
        help_text="The user receiving the disbursement."
    )
    amount = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        help_text="The disbursed amount in JPY."
    )
    transaction_id = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="Transaction ID returned by the PayPal API."
    )
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default="PENDING",
        help_text="The current status of the disbursement."
    )
    message = models.TextField(
        blank=True,
        null=True,
        help_text="Optional message or error detail regarding the disbursement."
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Disbursement for {self.user} of {self.amount} JPY - {self.status}"
